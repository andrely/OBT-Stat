class Disambiguator
  attr_accessor :text, :hunpos_stream, :evaluator, :hunpos_output, :hun_idx

  def initialize(evaluator)
    @evaluator = evaluator

    @hunpos_seek_buf = nil
  end

  def run_hunpos
    # run hunpos
    i, @hunpos_stream, e = Open3.popen3 $hunpos_command
    
    # TODO: check what is actually passed to hunpos. Bug in OBNO paerser ???
    @text.sentences.each do |s|
      s.words.each do |w|
        # TODO split opp collocations from OB, eg. "i forbifarten"
        i.puts w.string.gsub(/\s/, "\n")
      end
    end
    
    i.close
    e.close

    @hunpos_output = []
    @hunpos_stream.each_line do |line|
      hun_word, hun_tag = line.split(/\s/)
      @hunpos_output.push([hun_word, hun_tag])
    end
    
  end

  def disambiguate
    @hun_idx = 0
    
    # get input
    @text = Text.new
    OBNOText.parse @text, ARGF.read
    
    run_hunpos
    
    @text.sentences.each do |s|
      s.words.each do |w|
        disambiguate_word(w)
        @hun_idx += 1
      end
    end

    if @hun_idx != @hunpos_output.length - 1
      $stderr.puts "ERROR: inconsistent number of hunpos words read, #{@hun_idx}//#{@hunpos_output.length - 1}"
    end
  end

  def disambiguate_word(word)
    hun_word, hun_tag = @hunpos_output[@hun_idx]

    # sanity check on input position
    # raise RuntimeError, hun_word, word.string if hun_word != word.string
    raise RuntimeError, "Illegal hunpos word", hun_word + "-" + word.string if not validate_hunpos_output(word, hun_word)

    selected_tag = nil

    # not ambigious
    if word.tags.count == 1
      selected_tag = word.tags.first

    # ambigious
    else
      # fetch tags
      tags = word.tags.collect {|t| t.clean_out_tag}

      # use hunpos tag if found, just take the first tag otherwise
      if tags.include? hun_tag
        $stderr.puts "ambiguity hunpos tag #{hun_tag} chosen"

        selected_tag = word.tag_by_string(hun_tag)

        raise RuntimeError if selected_tag.nil?
      else
        $stderr.puts "ambiguity ob tag #{word.tags.first.clean_out_tag} chosen"

        selected_tag = ob_select_tag(word.tags)
      end
    end

    puts word.string + "\t" + selected_tag.clean_out_tag + "\t" + selected_tag.lemma
  end

  # Selects a tag from available tags generated by OB heuristically
  def ob_select_tag(ob_tags)
    # Current heuristic is to just select the first tag
    return ob_tags.first
  end

  def validate_hunpos_output(word, hunpos_word)
    if hunpos_word == word.string
      return true
    else
      # join up collocations from OB, eg. "i forbifarten"
      combined_hunpos_word = hunpos_word + " " + @hunpos_output[@hun_idx + 1][0]

      if combined_hunpos_word == word.string
        @hun_idx += 1
        return @hunpos_output[@hun_idx][1]
      end
    end
    
    # somehow there is a discrepancy between hunpos and OB output
    $stderr.puts "ERROR: word #{word} does not match hunpos word #{hunpos_word}"
    return nil
  end
end
