class Disambiguator
  attr_accessor :text, :hunpos_stream, :evaluator, :hunpos_output, :hun_idx, :text_idx

  def initialize(evaluator)
    @evaluator = evaluator

    @hunpos_seek_buf = nil
  end

  def run_hunpos
    # run hunpos
    i, @hunpos_stream, e = Open3.popen3 $hunpos_command
    
    # TODO: check what is actually passed to hunpos. Bug in OBNO paerser ???
    @text.sentences.each do |s|
      s.words.each do |w|
        # TODO split opp collocations from OB, eg. "i forbifarten"
        i.puts w.string.gsub(/\s/, "\n")
      end
    end
    
    i.close
    e.close

    @hunpos_output = []
    @hunpos_stream.each_line do |line|
      hun_word, hun_tag = line.split(/\s/)
      @hunpos_output.push([hun_word, hun_tag])
    end
    
  end

  def disambiguate
    @hun_idx = 0
    @text_idx = 0
    
    # get input
    @text = Text.new
    OBNOText.parse @text, ARGF.read
    
    run_hunpos
    
    @text.sentences.each do |s|
      s.words.each do |w|
        disambiguate_word(w)
        @hun_idx += 1
        @text_idx += 1
      end
    end

    if @hun_idx != @hunpos_output.length - 1
      $stderr.puts "ERROR: inconsistent number of hunpos words read, #{@hun_idx}//#{@hunpos_output.length - 1}"
    end

    @evaluator.print_summary($stderr)
  end

  def disambiguate_word(word)
    hun_word, hun_tag = @hunpos_output[@hun_idx]
      
    raise RuntimeError, "Invalid input" if not validate_word(word)

    selected_tag = nil

    # not ambigious
    if word.tags.count == 1
      selected_tag = word.tags.first

    # ambigious
    else
      # fetch tags
      tags = word.tags.collect {|t| t.clean_out_tag}

      # use hunpos tag if found, just take the first tag otherwise
      if tags.include? hun_tag
        $stderr.puts "ambiguity hunpos tag #{hun_tag} chosen"
        @evaluator.mark_hunpos_resolved

        selected_tag = word.tag_by_string(hun_tag)

        raise RuntimeError if selected_tag.nil?
      else
        $stderr.puts "ambiguity ob tag #{word.tags.first.clean_out_tag} chosen"
        @evaluator.mark_ob_resolved

        selected_tag = ob_select_tag(word.tags)
      end
    end

    puts word.string + "\t" + selected_tag.clean_out_tag + "\t" + selected_tag.lemma
  end

  # Selects a tag from available tags generated by OB heuristically
  def ob_select_tag(ob_tags)
    # Current heuristic is to just select the first tag
    return ob_tags.first
  end
  
  def validate_word(word)
    if word.string.include? " "
      words = word.string.split(" ")
      
      hunpos_words = @hunpos_output[@hun_idx...(@hun_idx + words.count)]
      hunpos_words = hunpos_words.collect {|x| x.first}
      raise RuntimeError "Invalid word" if words != hunpos_words
      return false if words != hunpos_words
      
      @hun_idx += words.count - 1
      return true
    else
      hun_word, hun_tag = @hunpos_output[@hun_idx]
      
      return word.string == hun_word
    end
  end

  def validate_hunpos_output(word, hunpos_word)
    if hunpos_word == word.string
      return true
    else
      # join up collocations from OB, eg. "i forbifarten"
      combined_hunpos_word = hunpos_word + " " + @hunpos_output[@hun_idx + 1][0]

      $stderr.puts combined_hunpos_word
      
      if combined_hunpos_word == word.string
        @hun_idx += 1
        return @hunpos_output[@hun_idx][1]
      else
        # join up collocations from OB, eg. "i forbifarten"
        combined_hunpos_word = combined_hunpos_word + " " + @hunpos_output[@hun_idx + 2][0]

        $stderr.puts combined_hunpos_word
        
        if combined_hunpos_word == word.string
          @hun_idx += 2
          return @hunpos_output[@hun_idx][1]
        end
      end
    end
    
    # somehow there is a discrepancy between hunpos and OB output
    $stderr.puts "ERROR: word #{word} does not match hunpos word #{hunpos_word}"
    return nil
  end
end
